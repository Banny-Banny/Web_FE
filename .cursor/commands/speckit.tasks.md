---
description: 사용 가능한 설계 문서를 기반으로 기능에 대한 실행 가능한 의존성 순서 tasks.md를 생성합니다
handoffs: 
  - label: 일관성 분석
    agent: speckit.analyze
    prompt: 일관성을 위한 프로젝트 분석 실행
    send: true
  - label: 프로젝트 구현
    agent: speckit.implement
    prompt: 단계별 구현 시작
    send: true
---

## 사용자 입력

```text
$ARGUMENTS
```

진행하기 전에 사용자 입력을 **반드시** 고려해야 합니다 (비어있지 않은 경우).

## 개요

TimeEgg Web Frontend 프로젝트를 위한 실행 가능한 작업 목록을 생성합니다.

### 1. 작업 생성 원칙

**사용자 스토리 기반 구성**:
- 각 사용자 스토리(P1, P2, P3...)가 독립적인 단계가 됨
- 모든 관련 컴포넌트를 해당 스토리에 매핑
- 스토리 의존성 표시 (대부분 독립적이어야 함)

**Feature Slice Architecture 준수**:
- 각 기능은 완전한 슬라이스로 구현
- 컨테이너 → 훅 → 컴포넌트 순서
- 공용 자산은 `commons/`에 배치

### 2. 작업 형식 (필수)

모든 작업은 다음 형식을 **엄격히** 준수해야 합니다:

```text
- [ ] [TaskID] [P?] [Story?] 설명과 파일 경로
```

**형식 구성 요소**:

1. **체크박스**: 항상 `- [ ]`로 시작 (마크다운 체크박스)
2. **작업 ID**: 실행 순서대로 순차 번호 (T001, T002, T003...)
3. **[P] 마커**: 병렬 처리 가능한 작업에만 포함 (다른 파일, 완료되지 않은 작업에 의존성 없음)
4. **[Story] 라벨**: 사용자 스토리 단계 작업에만 필요
   - 형식: [US1], [US2], [US3] 등 (spec.md의 사용자 스토리에 매핑)
   - 설정 단계: 스토리 라벨 없음
   - 기초 단계: 스토리 라벨 없음  
   - 사용자 스토리 단계: 스토리 라벨 필수
   - 마무리 단계: 스토리 라벨 없음
5. **설명**: 정확한 파일 경로가 포함된 명확한 작업

**올바른 예시**:
- ✅ `- [ ] T001 프로젝트 구조 생성`
- ✅ `- [ ] T005 [P] src/commons/apis/auth/auth.ts에 인증 미들웨어 구현`
- ✅ `- [ ] T012 [P] [US1] src/components/user/types.ts에 User 모델 생성`
- ✅ `- [ ] T014 [US1] src/components/user/hooks/useUser.ts에 UserService 구현`

**잘못된 예시**:
- ❌ `- [ ] User 모델 생성` (ID 및 스토리 라벨 누락)
- ❌ `T001 [US1] 모델 생성` (체크박스 누락)
- ❌ `- [ ] [US1] User 모델 생성` (작업 ID 누락)
- ❌ `- [ ] T001 [US1] 모델 생성` (파일 경로 누락)

### 3. TimeEgg 워크플로우 기반 단계 구조

**Phase 1: 프로젝트 설정**
- 프로젝트 초기화
- 의존성 설치 및 설정
- 기본 폴더 구조 생성

**Task 2: [Mobile Frame Implementation]**
- `app/layout.tsx`에 쿠캣 스타일의 중앙 고정 컨테이너를 먼저 구축합니다.
- 모든 하위 컴포넌트는 부모 컨테이너의 너비(`w-full`)를 따르되, 절대 수치는 375px 시안을 기준으로 작성합니다.
- 배경 설정: 컨텐츠 영역 밖(좌우 여백)은 프로젝트 메인 배경색(`bg-[#F4F5F7]`)으로 채웁니다.

**Phase 2: API 연동 레이어**
- API 클라이언트 설정 (`commons/apis/`)
- 타입 정의 (요청/응답 인터페이스)
- 에러 핸들링 및 인터셉터
- API 통합 테스트

**Phase 3: E2E 테스트 인프라**
- 테스트 환경 설정
- 주요 사용자 시나리오 테스트 작성
- 데이터 플로우 검증 테스트

**Phase 4+: 사용자 스토리별 UI 개발 (Mock 데이터)**
우선순위 순서대로 (P1, P2, P3...):
- 각 스토리별 Mock 데이터 생성
- UI 컴포넌트 구현 (타입 → 컴포넌트 → 스타일)
- 사용자 상호작용 구현
- **중요**: 실제 API 연결 없이 Mock 데이터로만 동작

**Phase N: 사용자 승인 및 피드백**
- 스테이징 환경 배포
- UI/UX 검증 및 개선사항 수집

**Phase N+1: 데이터 바인딩**
각 사용자 스토리별로:
- Mock 데이터를 실제 API 호출로 교체
- 상태 관리 연결 (React Query + Context Provider)
- 로딩/에러 상태 처리
- 비즈니스 로직 훅 구현

**최종 단계: UI 테스트 및 최적화**
- 컴포넌트 단위 테스트
- 통합 테스트 실행
- 성능 및 접근성 검증
- 문서화

### 4. 작업 매핑 규칙

**사용자 스토리에서 (spec.md)** - 주요 구성:
- 각 사용자 스토리(P1, P2, P3...)가 자체 단계를 가짐
- 모든 관련 컴포넌트를 해당 스토리에 매핑:
  - 해당 스토리에 필요한 모델
  - 해당 스토리에 필요한 서비스
  - 해당 스토리에 필요한 엔드포인트/UI
  - 해당 스토리에 특정한 테스트 (요청된 경우)

**계획에서 (plan.md)**:
- 기술 스택 → 설정 작업
- 아키텍처 결정 → 구조 작업
- 의존성 → 설치 및 설정 작업

**데이터 모델에서**:
- 각 엔티티를 필요로 하는 사용자 스토리에 매핑
- 여러 스토리에서 사용하는 엔티티: 가장 빠른 스토리 또는 설정 단계에 배치
- 관계 → 적절한 스토리 단계의 서비스 레이어 작업

### 5. TimeEgg 워크플로우 기반 작업 패턴

#### API 연동 단계 (Phase 2)
```text
commons/apis/[feature]/
├── T0XX types.ts 생성 - API 요청/응답 타입
└── T0XX client.ts 생성 - API 클라이언트 함수
```

#### E2E 테스트 단계 (Phase 3) - Playwright
```text
tests/e2e/[feature]/
├── T0XX [feature].e2e.spec.ts - 기능별 E2E 테스트 (하나의 파일)
└── T0XX fixtures/mockData.ts - 테스트용 Mock 데이터
```

#### UI 개발 단계 (Phase 4+) - Mock 데이터 기반
```text
components/[feature]/
├── T0XX [US1] types.ts 생성 - 컴포넌트 타입 정의
├── T0XX [US1] mocks/data.ts 생성 - Mock 데이터
├── T0XX [P] [US1] components/[sub-component]/index.tsx - UI 컴포넌트
├── T0XX [P] [US1] components/[sub-component]/styles.mocules.css - 스타일
├── T0XX [US1] index.tsx 생성 - 컨테이너 (Mock 데이터 사용)
└── T0XX [US1] app/[route]/page.tsx에 통합 - 라우팅
```

#### 데이터 바인딩 단계 (Phase N+1)
```text
components/[feature]/
├── T0XX [US1] hooks/use[Feature].ts 생성 - 실제 API 연결 훅
├── T0XX [US1] index.tsx 수정 - Mock → 실제 데이터로 교체
└── T0XX [US1] components/ 수정 - 로딩/에러 상태 추가
```

#### UI 테스트 단계 (최종) - Playwright
```text
tests/ui/[feature]/
└── T0XX [P] [feature].ui.spec.ts - 기능별 UI 테스트 (하나의 파일)
```

### 6. 의존성 및 병렬 처리

**순차 실행이 필요한 경우**:
- 같은 파일을 수정하는 작업들
- 이전 작업의 결과에 의존하는 작업
- 기초 설정이 완료되어야 하는 작업

**병렬 처리 가능한 경우** `[P]`:
- 다른 파일에서 작업하는 경우
- 완료되지 않은 작업에 의존성이 없는 경우
- 독립적인 컴포넌트 개발

### 7. 작업 완성도 검증

각 사용자 스토리에 대해:
- [ ] 모든 필요한 작업이 포함되었는지 확인
- [ ] 독립적으로 테스트 가능한지 확인
- [ ] 파일 경로가 Feature Slice Architecture를 준수하는지 확인
- [ ] 의존성이 올바르게 순서화되었는지 확인

### 8. 출력 형식

생성된 `tasks.md`에는 다음이 포함되어야 합니다:

- 올바른 기능 이름 (plan.md에서)
- 단계별 작업 목록
- 의존성 섹션 (스토리 완료 순서)
- 병렬 실행 예시
- 구현 전략 섹션 (MVP 우선, 점진적 전달)
- 모든 작업이 체크리스트 형식을 준수하는지 형식 검증

### 9. 보고서

작업 생성 완료 후 다음을 보고:
- 생성된 tasks.md 경로
- 총 작업 수
- 사용자 스토리별 작업 수
- 식별된 병렬 처리 기회
- 각 스토리에 대한 독립적 테스트 기준
- 제안된 MVP 범위 (일반적으로 사용자 스토리 1만)

---

**참고**: tasks.md는 즉시 실행 가능해야 하며, 각 작업은 LLM이 추가 컨텍스트 없이 완료할 수 있을 만큼 구체적이어야 합니다.