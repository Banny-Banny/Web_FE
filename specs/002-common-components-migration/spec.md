# 공통 컴포넌트 및 모달 프로바이더 마이그레이션 명세서

**Feature Branch**: `migrate-common-components`  
**Created**: 2026-01-25  
**Status**: Draft  
**Input**: User description: "공통 컴포넌트 + 모달 프로바이더 들 마이그레이션 할거야. rn expo -> 지금 우리 프로젝트로 옮길건데 저기서 썼던 코드들을 통으로 하나씩 줄거야. 모달이나 토스트의 경우 프로바이더 만들어야 하면 만들도록해"

## 📋 개요

### 프로젝트 목표
기존 모바일 애플리케이션에서 사용되던 공통 UI 컴포넌트와 전역 상태 관리 프로바이더를 웹 애플리케이션으로 마이그레이션하여, 일관된 사용자 경험과 개발 효율성을 확보합니다.

### 비즈니스 가치
- **개발 효율성 향상**: 재사용 가능한 공통 컴포넌트로 개발 속도 향상 및 코드 중복 제거
- **일관된 사용자 경험**: 모바일과 웹 간 동일한 UI 패턴으로 사용자 혼란 최소화
- **유지보수성 개선**: 중앙화된 컴포넌트 관리로 디자인 변경 시 일괄 적용 가능
- **전역 상태 관리**: 모달, 토스트 등 전역 UI 요소의 효율적인 관리

### 범위
- **포함**: 
  - 공통 UI 컴포넌트 (버튼, 듀얼 버튼, 스피너, 바텀시트, 타임캡슐 헤더)
  - 전역 UI 컴포넌트 (모달, 토스트)
  - 전역 프로바이더 (모달 프로바이더, 토스트 프로바이더 - 필요한 경우)
  - 컴포넌트 타입 정의 및 인터페이스
  - `src/app/(main)/page.tsx`에 모든 공통 컴포넌트 미리보기 페이지 구성
- **제외**: 
  - 각 컴포넌트의 비즈니스 로직 구현
  - 컴포넌트를 사용하는 실제 기능 페이지 구현
  - 라우팅 관련 구현 (app 디렉토리는 라우팅 전용, 컴포넌트 import만 수행)

### 아키텍처 제약사항
- **app 디렉토리**: 라우팅 전용으로 사용되며, 비즈니스 로직이나 컴포넌트 구현은 포함하지 않음
- **컴포넌트 배치**: 모든 공통 컴포넌트는 `src/commons/components/` 디렉토리에 배치
- **프로바이더 배치**: 전역 프로바이더는 `src/commons/providers/` 디렉토리에 배치

### 디자인 리소스
- **Figma MCP**: 디자인 구현 시 Figma MCP 서버를 통해 정확한 디자인 스펙을 참조합니다
- **Figma MCP 주소**: [Figma MCP 주소는 구현 단계에서 제공됩니다]
- **디자인 토큰**: Figma에서 정의된 색상, 간격, 타이포그래피 등의 디자인 토큰을 프로젝트의 `tailwind.config.js`에 선언된 변수로 import하여 사용합니다
- **디자인 정확도**: 모든 컴포넌트의 스타일, 크기, 간격은 Figma 디자인과 정확히 일치해야 합니다

---

## 🎯 사용자 시나리오

### US1: 개발자가 공통 버튼 컴포넌트를 사용하여 UI 구성 (Priority: P1)

**시나리오**: 개발자가 다양한 페이지에서 일관된 버튼 스타일을 빠르게 적용하고 싶을 때

**사용자 행동**:
1. 개발자가 새로운 페이지나 기능을 개발 중
2. 버튼 컴포넌트를 import하여 사용
3. 버튼의 다양한 변형(primary, secondary 등)과 크기를 선택하여 적용

**기대 결과**:
- 개발자가 공통 버튼 컴포넌트를 쉽게 찾아서 사용할 수 있음
- 버튼의 스타일이 프로젝트 전체에서 일관되게 적용됨
- 버튼의 다양한 변형과 크기를 props로 간단히 설정 가능
- 버튼 클릭 시 의도한 동작이 정확히 수행됨

**성공 기준**:
- 개발자가 공통 버튼 컴포넌트를 import하여 사용하는 데 걸리는 시간이 1분 이하
- 프로젝트 전체에서 버튼 스타일 일관성 100%
- 버튼의 모든 변형과 크기가 정상적으로 렌더링됨

**Acceptance Scenarios**:
1. **Given** 개발자가 버튼 컴포넌트를 import했을 때, **When** 기본 props로 사용하면, **Then** 기본 스타일의 버튼이 정상적으로 표시됨
2. **Given** 개발자가 버튼 컴포넌트를 사용할 때, **When** variant와 size props를 변경하면, **Then** 해당 스타일이 정확히 적용됨
3. **Given** 개발자가 버튼에 onClick 핸들러를 연결했을 때, **When** 버튼을 클릭하면, **Then** 핸들러가 정확히 실행됨

---

### US2: 개발자가 듀얼 버튼 컴포넌트를 사용하여 두 가지 액션 제공 (Priority: P1)

**시나리오**: 개발자가 하나의 UI 영역에서 두 가지 선택지를 제공하고 싶을 때

**사용자 행동**:
1. 개발자가 확인/취소, 예/아니오 등 두 가지 선택이 필요한 UI를 구성
2. 듀얼 버튼 컴포넌트를 import하여 사용
3. 각 버튼에 적절한 라벨과 핸들러를 설정

**기대 결과**:
- 두 개의 버튼이 나란히 배치되어 표시됨
- 각 버튼이 독립적으로 클릭 가능함
- 두 버튼의 스타일이 시각적으로 구분됨
- 각 버튼 클릭 시 해당 핸들러가 정확히 실행됨

**성공 기준**:
- 듀얼 버튼 컴포넌트 사용 시 두 버튼이 정상적으로 나란히 표시됨
- 각 버튼의 클릭 이벤트가 독립적으로 처리됨
- 두 버튼의 시각적 구분이 명확함

**Acceptance Scenarios**:
1. **Given** 개발자가 듀얼 버튼 컴포넌트를 사용했을 때, **When** 두 개의 버튼 props를 전달하면, **Then** 두 버튼이 나란히 정상적으로 표시됨
2. **Given** 듀얼 버튼이 렌더링되었을 때, **When** 각 버튼을 클릭하면, **Then** 해당 버튼의 핸들러가 정확히 실행됨

---

### US3: 사용자가 모달을 통해 중요한 정보를 확인하거나 액션을 수행 (Priority: P1)

**시나리오**: 사용자가 앱 내에서 확인, 입력, 선택 등의 작업을 모달을 통해 수행할 때

**사용자 행동**:
1. 사용자가 특정 액션을 수행 (예: 삭제 확인, 정보 입력)
2. 모달이 화면에 표시됨
3. 사용자가 모달 내에서 확인 또는 취소 선택
4. 모달이 닫히고 결과가 반영됨

**기대 결과**:
- 모달이 화면 중앙에 오버레이와 함께 표시됨
- 모달 배경(오버레이) 클릭 시 모달이 닫힘
- 모달 내 확인/취소 버튼 클릭 시 적절한 동작 수행
- 모달이 닫힌 후 화면이 정상 상태로 복귀됨
- 여러 모달이 동시에 열릴 수 있는 경우 적절히 스택 관리됨

**성공 기준**:
- 모달 표시 시 화면 중앙에 정확히 배치됨
- 모달 오버레이 클릭 시 모달 닫힘 성공률 100%
- 모달 내 버튼 클릭 시 의도한 동작 수행 성공률 100%
- 모달이 닫힌 후 화면 상태 복귀 성공률 100%

**Acceptance Scenarios**:
1. **Given** 개발자가 모달을 열었을 때, **When** 모달이 렌더링되면, **Then** 화면 중앙에 오버레이와 함께 표시됨
2. **Given** 모달이 열려있을 때, **When** 사용자가 오버레이를 클릭하면, **Then** 모달이 닫힘
3. **Given** 모달이 열려있을 때, **When** 사용자가 모달 내 확인 버튼을 클릭하면, **Then** 확인 핸들러가 실행되고 모달이 닫힘
4. **Given** 여러 모달이 열려있을 때, **When** 최상위 모달을 닫으면, **Then** 이전 모달이 정상적으로 표시됨

---

### US4: 사용자가 토스트 메시지를 통해 작업 결과를 즉시 확인 (Priority: P1)

**시나리오**: 사용자가 작업을 수행한 후 성공, 실패, 정보 등의 피드백을 받을 때

**사용자 행동**:
1. 사용자가 특정 작업을 수행 (예: 저장, 삭제, 업로드)
2. 작업 결과에 따라 토스트 메시지가 화면에 표시됨
3. 사용자가 메시지를 확인함
4. 토스트가 자동으로 사라지거나 사용자가 닫기 버튼을 클릭

**기대 결과**:
- 토스트 메시지가 화면의 적절한 위치(일반적으로 상단 또는 하단)에 표시됨
- 토스트 메시지가 일정 시간 후 자동으로 사라짐
- 여러 토스트가 동시에 표시될 경우 적절히 스택 관리됨
- 토스트의 타입(성공, 에러, 정보, 경고)에 따라 시각적으로 구분됨

**성공 기준**:
- 토스트 메시지 표시 성공률 100%
- 토스트 메시지가 설정된 시간 후 자동으로 사라짐
- 여러 토스트가 동시에 표시될 때 겹침 없이 정상 표시됨
- 토스트 타입별 시각적 구분이 명확함

**Acceptance Scenarios**:
1. **Given** 개발자가 토스트를 표시했을 때, **When** 토스트가 렌더링되면, **Then** 화면의 적절한 위치에 표시됨
2. **Given** 토스트가 표시되었을 때, **When** 설정된 시간이 지나면, **Then** 토스트가 자동으로 사라짐
3. **Given** 여러 토스트가 동시에 표시될 때, **When** 새로운 토스트가 추가되면, **Then** 기존 토스트와 겹침 없이 정상 표시됨
4. **Given** 토스트가 표시되었을 때, **When** 사용자가 닫기 버튼을 클릭하면, **Then** 토스트가 즉시 사라짐

---

### US5: 개발자가 스피너 컴포넌트를 사용하여 로딩 상태 표시 (Priority: P2)

**시나리오**: 개발자가 비동기 작업 중 로딩 상태를 사용자에게 시각적으로 표시하고 싶을 때

**사용자 행동**:
1. 개발자가 데이터 로딩, 파일 업로드 등 비동기 작업을 수행
2. 스피너 컴포넌트를 사용하여 로딩 상태 표시
3. 작업이 완료되면 스피너가 사라짐

**기대 결과**:
- 스피너가 화면에 애니메이션과 함께 표시됨
- 스피너의 크기와 색상을 props로 조정 가능
- 스피너가 로딩 상태를 명확하게 전달함

**성공 기준**:
- 스피너가 정상적으로 애니메이션됨
- 스피너의 크기와 색상이 props에 따라 정확히 적용됨

**Acceptance Scenarios**:
1. **Given** 개발자가 스피너 컴포넌트를 사용했을 때, **When** 스피너가 렌더링되면, **Then** 애니메이션과 함께 정상적으로 표시됨
2. **Given** 스피너가 표시되었을 때, **When** size와 color props를 변경하면, **Then** 해당 스타일이 정확히 적용됨

---

### US6: 개발자가 바텀시트 컴포넌트를 사용하여 하단에서 올라오는 메뉴 제공 (Priority: P2)

**시나리오**: 개발자가 화면 하단에서 올라오는 선택 메뉴나 옵션 목록을 제공하고 싶을 때

**사용자 행동**:
1. 개발자가 사용자에게 여러 선택지를 제공하고 싶음
2. 바텀시트 컴포넌트를 사용하여 하단에서 올라오는 메뉴 구성
3. 사용자가 옵션을 선택하거나 바텀시트를 닫음

**기대 결과**:
- 바텀시트가 화면 하단에서 부드럽게 올라옴
- 바텀시트 배경(오버레이) 클릭 시 바텀시트가 닫힘
- 바텀시트 내 옵션 선택 시 해당 핸들러가 실행됨
- 바텀시트가 닫힐 때 부드럽게 하단으로 사라짐

**성공 기준**:
- 바텀시트가 하단에서 올라오는 애니메이션이 부드럽게 작동함
- 바텀시트 오버레이 클릭 시 닫힘 성공률 100%
- 바텀시트 내 옵션 선택 시 핸들러 실행 성공률 100%

**Acceptance Scenarios**:
1. **Given** 개발자가 바텀시트를 열었을 때, **When** 바텀시트가 렌더링되면, **Then** 화면 하단에서 부드럽게 올라옴
2. **Given** 바텀시트가 열려있을 때, **When** 사용자가 오버레이를 클릭하면, **Then** 바텀시트가 닫힘
3. **Given** 바텀시트가 열려있을 때, **When** 사용자가 옵션을 선택하면, **Then** 해당 핸들러가 실행되고 바텀시트가 닫힘

---

### US7: 개발자가 타임캡슐 헤더 컴포넌트를 사용하여 페이지 헤더 구성 (Priority: P3)

**시나리오**: 개발자가 타임캡슐 관련 페이지에서 일관된 헤더를 사용하고 싶을 때

**사용자 행동**:
1. 개발자가 타임캡슐 관련 페이지를 구성
2. 타임캡슐 헤더 컴포넌트를 사용하여 페이지 상단 구성
3. 헤더에 필요한 정보와 액션 버튼 배치

**기대 결과**:
- 타임캡슐 헤더가 페이지 상단에 일관되게 표시됨
- 헤더의 구성 요소(제목, 버튼 등)가 정상적으로 작동함
- 헤더의 스타일이 프로젝트 디자인 시스템과 일치함

**성공 기준**:
- 타임캡슐 헤더가 모든 타임캡슐 관련 페이지에서 일관되게 표시됨
- 헤더 내 모든 인터랙티브 요소가 정상적으로 작동함

**Acceptance Scenarios**:
1. **Given** 개발자가 타임캡슐 헤더 컴포넌트를 사용했을 때, **When** 헤더가 렌더링되면, **Then** 페이지 상단에 정상적으로 표시됨
2. **Given** 타임캡슐 헤더가 표시되었을 때, **When** 헤더 내 버튼을 클릭하면, **Then** 해당 핸들러가 정확히 실행됨

---

### US8: 개발자가 마이그레이션된 모든 공통 컴포넌트를 한 페이지에서 확인 및 테스트 (Priority: P1)

**시나리오**: 개발자가 마이그레이션된 모든 공통 컴포넌트를 한 곳에서 확인하고 테스트하고 싶을 때

**사용자 행동**:
1. 개발자가 `src/app/(main)/page.tsx` 페이지에 접근
2. 페이지에서 마이그레이션된 모든 공통 컴포넌트를 확인
3. 각 컴포넌트의 다양한 variant, size, 상태를 테스트
4. 모달, 토스트, 바텀시트 등 인터랙티브 컴포넌트의 동작을 확인

**기대 결과**:
- `src/app/(main)/page.tsx`에서 모든 마이그레이션된 공통 컴포넌트를 한눈에 볼 수 있음
- 각 컴포넌트의 다양한 변형(variant, size)이 모두 표시됨
- 각 컴포넌트의 상태(disabled, loading 등)를 확인할 수 있음
- 모달, 토스트, 바텀시트 등 인터랙티브 컴포넌트를 실제로 동작시켜 볼 수 있음
- 컴포넌트들이 섹션별로 구분되어 정리되어 있음

**성공 기준**:
- `src/app/(main)/page.tsx`에서 모든 마이그레이션된 공통 컴포넌트가 표시됨
- 각 컴포넌트의 모든 variant와 size가 표시됨
- 모든 인터랙티브 컴포넌트가 정상적으로 동작함
- 컴포넌트들이 명확하게 구분되어 표시됨

**Acceptance Scenarios**:
1. **Given** 개발자가 `src/app/(main)/page.tsx`에 접근했을 때, **When** 페이지가 로드되면, **Then** 모든 마이그레이션된 공통 컴포넌트가 표시됨
2. **Given** 컴포넌트 미리보기 페이지가 표시되었을 때, **When** 각 컴포넌트의 variant와 size를 확인하면, **Then** 모든 변형이 정상적으로 표시됨
3. **Given** 인터랙티브 컴포넌트(모달, 토스트, 바텀시트)가 표시되었을 때, **When** 해당 컴포넌트를 트리거하면, **Then** 컴포넌트가 정상적으로 동작함
4. **Given** 컴포넌트 미리보기 페이지가 표시되었을 때, **When** 각 컴포넌트 섹션을 확인하면, **Then** 컴포넌트들이 명확하게 구분되어 표시됨

---

### Edge Cases

- **EC-001**: 모달이나 토스트가 동시에 여러 개 열릴 때 스택 관리가 올바르게 작동하는가?
- **EC-002**: 모달이나 토스트 프로바이더가 앱 최상위 레벨에 제대로 마운트되지 않았을 때 어떻게 처리하는가?
- **EC-003**: 컴포넌트에 필수 props가 누락되었을 때 적절한 에러 메시지나 기본값이 제공되는가?
- **EC-004**: 모달이나 바텀시트가 열려있을 때 사용자가 브라우저 뒤로가기를 누르면 어떻게 처리하는가?
- **EC-005**: 토스트 메시지가 매우 긴 텍스트를 포함할 때 레이아웃이 깨지지 않는가?
- **EC-006**: 스피너가 표시되는 동안 사용자가 다른 작업을 수행할 수 있는가? (비활성화 처리 필요 여부)

---

## 📋 기능 요구사항

### FR-001: 공통 버튼 컴포넌트
**설명**: 프로젝트 전체에서 일관되게 사용할 수 있는 재사용 가능한 버튼 컴포넌트를 제공합니다.

**요구사항**:
- 버튼 컴포넌트는 다양한 variant(primary, secondary 등)를 지원해야 함
- 버튼 컴포넌트는 다양한 size(small, medium, large 등)를 지원해야 함
- 버튼 컴포넌트는 disabled 상태를 지원해야 함
- 버튼 컴포넌트는 loading 상태를 지원해야 함 (선택적)
- 버튼 클릭 시 onClick 핸들러가 정확히 실행되어야 함
- 버튼의 스타일이 프로젝트 디자인 시스템을 준수해야 함

**검증 기준**:
- 모든 variant와 size 조합이 정상적으로 렌더링됨
- disabled 상태에서 버튼이 비활성화되고 클릭되지 않음
- onClick 핸들러가 정확히 실행됨
- 버튼 스타일이 디자인 시스템과 일치함

### FR-002: 듀얼 버튼 컴포넌트
**설명**: 두 개의 버튼을 나란히 배치하여 두 가지 선택지를 제공하는 컴포넌트를 제공합니다.

**요구사항**:
- 두 개의 버튼이 나란히 배치되어야 함
- 각 버튼은 독립적인 라벨, 스타일, 핸들러를 가져야 함
- 두 버튼의 시각적 구분이 명확해야 함
- 각 버튼의 클릭 이벤트가 독립적으로 처리되어야 함

**검증 기준**:
- 두 버튼이 정상적으로 나란히 표시됨
- 각 버튼의 클릭 이벤트가 독립적으로 처리됨
- 두 버튼의 시각적 구분이 명확함

### FR-003: 스피너 컴포넌트
**설명**: 로딩 상태를 시각적으로 표시하는 스피너 컴포넌트를 제공합니다.

**요구사항**:
- 스피너가 부드러운 애니메이션과 함께 표시되어야 함
- 스피너의 크기를 props로 조정할 수 있어야 함
- 스피너의 색상을 props로 조정할 수 있어야 함 (선택적)
- 스피너가 로딩 상태를 명확하게 전달해야 함

**검증 기준**:
- 스피너가 정상적으로 애니메이션됨
- 스피너의 크기와 색상이 props에 따라 정확히 적용됨

### FR-004: 바텀시트 컴포넌트
**설명**: 화면 하단에서 올라오는 선택 메뉴나 옵션 목록을 제공하는 컴포넌트를 제공합니다.

**요구사항**:
- 바텀시트가 화면 하단에서 부드럽게 올라와야 함
- 바텀시트 배경(오버레이)이 표시되어야 함
- 오버레이 클릭 시 바텀시트가 닫혀야 함
- 바텀시트 내 옵션 선택 시 해당 핸들러가 실행되어야 함
- 바텀시트가 닫힐 때 부드럽게 하단으로 사라져야 함

**검증 기준**:
- 바텀시트가 하단에서 올라오는 애니메이션이 부드럽게 작동함
- 오버레이 클릭 시 바텀시트가 닫힘
- 바텀시트 내 옵션 선택 시 핸들러가 정확히 실행됨

### FR-005: 타임캡슐 헤더 컴포넌트
**설명**: 타임캡슐 관련 페이지에서 일관되게 사용할 수 있는 헤더 컴포넌트를 제공합니다.

**요구사항**:
- 타임캡슐 헤더가 페이지 상단에 일관되게 표시되어야 함
- 헤더의 구성 요소(제목, 버튼 등)가 정상적으로 작동해야 함
- 헤더의 스타일이 프로젝트 디자인 시스템과 일치해야 함

**검증 기준**:
- 타임캡슐 헤더가 정상적으로 렌더링됨
- 헤더 내 모든 인터랙티브 요소가 정상적으로 작동함

### FR-006: 모달 컴포넌트 및 프로바이더
**설명**: 전역적으로 사용할 수 있는 모달 컴포넌트와 프로바이더를 제공합니다.

**요구사항**:
- 모달이 화면 중앙에 오버레이와 함께 표시되어야 함
- 모달 오버레이 클릭 시 모달이 닫혀야 함
- 모달 내 확인/취소 버튼 클릭 시 적절한 동작이 수행되어야 함
- 여러 모달이 동시에 열릴 수 있는 경우 스택 관리가 되어야 함
- 모달 프로바이더가 앱 최상위 레벨에 마운트되어야 함
- 개발자가 모달을 쉽게 열고 닫을 수 있는 API를 제공해야 함

**검증 기준**:
- 모달이 화면 중앙에 정확히 배치됨
- 오버레이 클릭 시 모달이 닫힘
- 모달 내 버튼 클릭 시 의도한 동작이 수행됨
- 여러 모달이 동시에 열릴 때 스택 관리가 올바르게 작동함
- 모달 프로바이더가 정상적으로 작동함

### FR-007: 토스트 컴포넌트 및 프로바이더
**설명**: 전역적으로 사용할 수 있는 토스트 메시지 컴포넌트와 프로바이더를 제공합니다.

**요구사항**:
- 토스트 메시지가 화면의 적절한 위치에 표시되어야 함
- 토스트 메시지가 일정 시간 후 자동으로 사라져야 함
- 여러 토스트가 동시에 표시될 경우 적절히 스택 관리되어야 함
- 토스트의 타입(성공, 에러, 정보, 경고)에 따라 시각적으로 구분되어야 함
- 토스트 프로바이더가 앱 최상위 레벨에 마운트되어야 함
- 개발자가 토스트를 쉽게 표시할 수 있는 API를 제공해야 함
- 사용자가 토스트를 수동으로 닫을 수 있어야 함 (선택적)

**검증 기준**:
- 토스트 메시지가 정상적으로 표시됨
- 토스트 메시지가 설정된 시간 후 자동으로 사라짐
- 여러 토스트가 동시에 표시될 때 겹침 없이 정상 표시됨
- 토스트 타입별 시각적 구분이 명확함
- 토스트 프로바이더가 정상적으로 작동함

### FR-008: 컴포넌트 타입 정의
**설명**: 모든 컴포넌트에 대한 TypeScript 타입 정의를 제공합니다.

**요구사항**:
- 모든 컴포넌트의 props에 대한 타입이 정의되어야 함
- 컴포넌트의 variant, size 등 enum 타입이 정의되어야 함
- 타입 정의가 명확하고 재사용 가능해야 함
- 타입 정의가 export되어 다른 곳에서 사용 가능해야 함

**검증 기준**:
- 모든 컴포넌트의 props 타입이 정의되어 있음
- TypeScript 컴파일 에러가 없음
- 타입 정의가 명확하고 사용하기 쉬움

### FR-009: 컴포넌트 통합 및 익스포트
**설명**: 모든 공통 컴포넌트를 중앙에서 관리하고 쉽게 import할 수 있도록 합니다.

**요구사항**:
- 모든 공통 컴포넌트가 `src/commons/components/` 디렉토리에 배치되어야 함
- `src/commons/components/index.ts` 파일에서 모든 컴포넌트를 export해야 함
- 개발자가 한 곳에서 모든 컴포넌트를 import할 수 있어야 함
- 프로바이더는 `src/commons/providers/` 디렉토리에 배치되어야 함

**검증 기준**:
- 모든 컴포넌트가 올바른 디렉토리에 배치됨
- `index.ts` 파일에서 모든 컴포넌트가 export됨
- 개발자가 컴포넌트를 쉽게 import할 수 있음

### FR-010: 공통 컴포넌트 미리보기 페이지 구성
**설명**: 마이그레이션된 모든 공통 컴포넌트를 `src/app/(main)/page.tsx`에서 확인하고 테스트할 수 있도록 구성합니다.

**요구사항**:
- `src/app/(main)/page.tsx`에 모든 마이그레이션된 공통 컴포넌트가 표시되어야 함
- 각 컴포넌트의 모든 variant와 size가 표시되어야 함
- 각 컴포넌트의 다양한 상태(disabled, loading 등)가 표시되어야 함
- 모달, 토스트, 바텀시트 등 인터랙티브 컴포넌트를 실제로 동작시킬 수 있는 트리거 버튼이 제공되어야 함
- 컴포넌트들이 섹션별로 구분되어 정리되어야 함
- 각 섹션에 컴포넌트 이름과 설명이 포함되어야 함
- 페이지는 라우팅 전용인 `app` 디렉토리의 특성을 유지하며, 컴포넌트 import만 수행해야 함

**검증 기준**:
- `src/app/(main)/page.tsx`에서 모든 마이그레이션된 공통 컴포넌트가 표시됨
- 각 컴포넌트의 모든 variant와 size가 표시됨
- 모든 인터랙티브 컴포넌트가 정상적으로 동작함
- 컴포넌트들이 명확하게 구분되어 표시됨
- 페이지가 `app` 디렉토리의 라우팅 전용 규칙을 준수함

---

## 🚀 비기능 요구사항 (NFR)

### 성능
- **NFR-001**: 각 컴포넌트의 초기 렌더링 시간이 100ms 이하
- **NFR-002**: 모달/토스트 프로바이더가 앱 로드 시간에 미치는 영향이 5% 이하
- **NFR-003**: 스피너 애니메이션이 60fps로 부드럽게 작동함

### 접근성
- **NFR-004**: 모든 인터랙티브 컴포넌트에 적절한 aria-label이 제공됨
- **NFR-005**: 키보드 네비게이션으로 모든 컴포넌트에 접근 가능함
- **NFR-006**: 모달이 열릴 때 포커스가 모달 내부로 이동하고, 닫힐 때 원래 위치로 복귀됨
- **NFR-007**: 모든 버튼의 최소 터치 타겟 크기가 44px × 44px 이상

### 사용자 경험
- **NFR-008**: 모달과 바텀시트의 애니메이션이 부드럽고 자연스러움 (300ms 이하)
- **NFR-009**: 토스트 메시지가 화면을 가리지 않고 적절한 위치에 표시됨
- **NFR-010**: 모든 컴포넌트가 모바일 환경에서 터치 인터랙션이 정상적으로 작동함

### 호환성
- **NFR-011**: 주요 브라우저(Chrome, Safari, Firefox)에서 모든 컴포넌트가 정상 동작
- **NFR-012**: 모바일 브라우저에서 모든 컴포넌트가 정상 동작

### 코드 품질
- **NFR-013**: 모든 컴포넌트가 TypeScript로 작성되고 타입 안전성이 보장됨
- **NFR-014**: 모든 컴포넌트가 프로젝트의 스타일 가이드를 준수함
- **NFR-015**: 컴포넌트 코드가 재사용 가능하고 유지보수하기 쉬움

---

## 🔍 엣지 케이스 및 예외 상황

### EC-001: 모달/토스트 스택 관리
**상황**: 여러 모달이나 토스트가 동시에 열릴 때

**처리 방법**:
- 모달의 경우 z-index를 사용하여 최신 모달이 최상위에 표시되도록 함
- 토스트의 경우 수직으로 스택하여 모두 표시하되 겹치지 않도록 함
- 모달/토스트가 닫힐 때 스택에서 제거하고 다음 항목이 표시되도록 함

### EC-002: 프로바이더 마운트 실패
**상황**: 모달/토스트 프로바이더가 앱 최상위 레벨에 마운트되지 않은 경우

**처리 방법**:
- 프로바이더 사용 시 경고 메시지 표시
- 프로바이더가 없을 때도 컴포넌트가 에러 없이 작동하도록 fallback 제공

### EC-003: 필수 props 누락
**상황**: 컴포넌트에 필수 props가 전달되지 않은 경우

**처리 방법**:
- TypeScript를 통해 컴파일 타임에 에러 감지
- 런타임에 기본값 제공 또는 명확한 에러 메시지 표시

### EC-004: 브라우저 뒤로가기 처리
**상황**: 모달이나 바텀시트가 열려있을 때 사용자가 브라우저 뒤로가기를 누름

**처리 방법**:
- 브라우저 히스토리에 모달/바텀시트 상태를 추가하여 뒤로가기 시 닫히도록 처리
- 또는 뒤로가기 시 모달/바텀시트를 닫고 페이지는 그대로 유지

### EC-005: 긴 텍스트 처리
**상황**: 토스트 메시지나 모달 내용이 매우 긴 경우

**처리 방법**:
- 텍스트가 길 경우 자동 줄바꿈 또는 스크롤 처리
- 레이아웃이 깨지지 않도록 최대 너비 및 높이 제한

### EC-006: 스피너 표시 중 사용자 인터랙션
**상황**: 스피너가 표시되는 동안 사용자가 다른 작업을 시도함

**처리 방법**:
- 스피너가 표시되는 영역을 비활성화하거나
- 스피너 사용 시점에 따라 전체 화면 또는 특정 영역만 비활성화
- 개발자가 선택할 수 있도록 옵션 제공

---

## 🎨 디자인 제약사항

### Figma MCP 활용
- **Figma MCP 서버**: 디자인 구현 시 Figma MCP 서버를 통해 정확한 디자인 스펙을 가져옵니다
- **Figma MCP 주소**: [구현 단계에서 제공될 Figma MCP 주소를 사용합니다]
- **디자인 토큰 추출**: Figma에서 색상(Color), 간격(Spacing), 반경(Radius), 타이포그래피(Typography) 등 디자인 토큰을 추출하여 사용합니다
- **에셋 처리**: Figma MCP 서버가 제공하는 이미지 및 SVG 에셋을 직접 사용합니다 (로컬 호스트 소스 포함)
- **디자인 정확도**: 모든 컴포넌트의 크기, 간격, 색상, 스타일은 Figma 디자인과 정확히 일치해야 합니다
- **소수점 값 처리**: Figma에서 추출한 모든 소수점이 포함된 수치 값은 반올림하여 정수로 변환합니다

### 컴포넌트 스타일
- **CSS Module 사용**: 모든 컴포넌트 스타일은 `styles.module.css` 파일에 CSS Module로 작성
- **디자인 토큰 준수**: 모든 컴포넌트가 프로젝트의 디자인 토큰 시스템을 준수해야 함
- **CSS 변수 사용**: 디자인 토큰은 CSS 변수로 참조
  - 디자인 토큰 정의: `src/commons/styles/` 디렉토리에 TypeScript 객체로 정의 (`color.ts`, `spacing.ts`, `fonts.ts`, `typography.ts`)
  - CSS 변수 생성: `src/app/layout.tsx`에서 `generateColorCSSVariables()`, `generateSpacingCSSVariables()`, `generateTypographyCSSVariables()` 함수로 CSS 변수 생성 후 `:root`에 주입
  - 컴포넌트에서 사용: `styles.module.css`에서 `var(--color-*)`, `var(--spacing-*)`, `var(--radius-*)`, `var(--font-*)` 등 CSS 변수로 참조
- **하드코딩 금지**: hex/rgb/hsl 직접 입력 금지, CSS 변수만 사용
- **인라인 스타일 금지**: `style={...}` 사용 금지
- **일관성**: 기존 디자인 시스템과 일관된 스타일 적용
- **반응형**: 모바일 환경을 기준으로 한 고정 레이아웃 (375px 기준)

### 모달 및 토스트
- **위치**: 모달은 화면 중앙, 토스트는 화면 상단 또는 하단에 표시
- **오버레이**: 모달과 바텀시트는 반투명 오버레이를 사용하여 배경을 어둡게 처리
- **애니메이션**: 모든 열기/닫기 애니메이션이 부드럽고 자연스러워야 함

### 접근성
- **색상 대비**: 모든 텍스트와 배경의 색상 대비가 WCAG AA 기준을 만족해야 함
- **포커스 표시**: 키보드 포커스가 명확하게 표시되어야 함

---

## 📊 성공 지표 (KPI)

### 개발 효율성
- **컴포넌트 재사용률**: 프로젝트 내 공통 컴포넌트 사용률 80% 이상
- **개발 시간 단축**: 공통 컴포넌트 사용으로 UI 개발 시간 30% 단축
- **코드 중복 감소**: 버튼, 모달 등 공통 UI 요소의 코드 중복 90% 감소
- **컴포넌트 확인 시간**: 개발자가 모든 공통 컴포넌트를 한 페이지에서 확인하는 데 걸리는 시간이 30초 이하

### 사용자 경험
- **일관성**: 프로젝트 전체에서 UI 컴포넌트 일관성 100%
- **접근성**: 모든 컴포넌트의 접근성 요구사항 준수율 100%
- **성능**: 컴포넌트 렌더링이 사용자 경험에 부정적 영향을 주지 않음

### 기술적 품질
- **타입 안전성**: TypeScript 컴파일 에러 0%
- **코드 품질**: 모든 컴포넌트가 프로젝트 스타일 가이드를 준수함
- **문서화**: 모든 컴포넌트의 사용법이 명확하게 문서화됨

---

## 🔗 기술 의존성

### 필수 라이브러리
- **React**: 컴포넌트 기반 UI 구축
- **TypeScript**: 타입 안전성 보장
- **Next.js**: 웹 프레임워크 (라우팅은 app 디렉토리 전용)

### 선택적 의존성
- **프로바이더 구현**: 모달/토스트 프로바이더 구현 시 React Context API 사용
- **애니메이션**: CSS transitions 또는 적절한 애니메이션 라이브러리

### 디자인 리소스
- **Figma MCP 서버**: 디자인 구현을 위한 Figma MCP 서버 연결
  - MCP 서버를 통해 Figma 디자인 파일에서 컴포넌트 스펙, 디자인 토큰, 에셋 등을 추출합니다
  - Figma MCP 주소는 구현 단계에서 제공됩니다

---

## 📝 가정사항

### 개발 환경
- 개발자는 TypeScript와 React에 익숙함
- 개발자는 프로젝트의 디자인 시스템을 이해하고 있음

### 사용자 환경
- 사용자는 모바일 기기에서 웹 애플리케이션을 주로 사용함
- 사용자는 터치 인터페이스에 익숙함

### 기술 환경
- Next.js App Router를 사용하여 라우팅 관리
- React 컴포넌트 기반으로 구현
- TypeScript를 사용하여 타입 안전성 보장
- 프로젝트의 기존 디자인 토큰 시스템을 준수함
- Figma MCP 서버를 통해 디자인 스펙을 정확하게 반영함

### 아키텍처
- `app/` 디렉토리는 라우팅 전용으로 사용됨
- 모든 공통 컴포넌트는 `src/commons/components/`에 배치됨
- 모든 프로바이더는 `src/commons/providers/`에 배치됨

---

## 🚧 향후 확장 가능성

### 향후 개선 사항
- 컴포넌트의 추가 variant 및 size 옵션
- 다크 모드 지원
- 국제화(i18n) 지원
- 컴포넌트별 스토리북 문서화

### 확장 가능한 기능
- 컴포넌트 테마 커스터마이징
- 애니메이션 효과 추가
- 접근성 기능 강화
- 컴포넌트 성능 최적화
